viewport:width=device-width,initial-scale=1

目录

[TOC]
##Ch4存储器管理
内存的管理,
外存的管理,外存主要存放文件,文件管理
###4.1存储系统的层次结构

+ 存储器的多层结构
+ 可执行存储器:寄存器,主存
+ 高速缓存和磁盘缓存
	- 紧靠内存的一级高速缓存速度最高,容量最小
	- <u>磁盘缓存:**并不是一种实际存在的存储器,而是利用主存中部分空间暂存从磁盘读入(写出)的信息**</u>
###4.2程序的装入和链接
用户程序装入内存,转变成一个可以执行的程序然后再系统中运行

+ 编译:->形成若干个目标模块
+ 链接:有链接程序将编译后形成的目标模块以及库函数链接在一起形成**装入模块**
+ 装入:由装入程序将装入模块装入内存
####4.2.1程序的装入
+ 绝对装入方式,使用绝对地址/物理地址
	- <u>将目标模块转入内存中事先制定的位置,只适用于单道程序环境</u>
+ 可重定位装入方式,逻辑地址相对于起始地址计算
	- 装入时对目标程序中指令和数据地址进行修改::=重定位
		+ 因为地址变换是在进程装入时一次完成,**静态重定位**
	- 装入模块可装入到内存中任何允许的位置,可用于多道程序
	但<u>不允许程序运行时在内存中移动位置</u>
		+ 因为移动了位置后,程序的起始地址发生了变化,,,
+ 动态运行时的装入方式
	- 程序装入到内存后,**地址转换推迟到程序真正执行时进行**
	- 为使地址转换不影响指令执行速度,需要**重定位寄存器**
####4.2.2程序的链接
<u>**根据进行链接的时间不同**</u>

1. 静态链接,<u>运行前链接</u>:将各目标模块及需要的函数库链接成一个完整的装配模块,以后不再拆开
	+ 应解决的一些问题
		- 修改相对地址
		- 变换外部调用符号
2. 装入时动态链接,<u>装入时链接</u>:装入内存时,边装入边链接
装入目标模块时,若发生一个外部模块调用事件,由装入程序找到装入之
	+ 优点:
		+ 便于修改和更新
		+ 便于实现对目标模块的共享
3. 运行时动态链接,<u>运行时链接</u>:对装入时动态链接的一种改进,**对某些模块的链接推迟到程序执行时才进行**
	+ 执行过程中未被用到的目标模块都不会被调入内存和被链接到装入模块上
###4.3连续分配存储管理方式
####4.3.1单一连续分配
单道程序环境;
存储器分为系统区和用户区
整个内存的用户空间由该程序独占
####4.3.2固定分区分配
多道程序,将整个用户空间划分为若干个固定大小的区域,每个分区只装入一道作业

1. 划分分区的方法
	+ 分区大小相等
		- 缺点:不灵活;
		- 对应利用一台计算机同时控制多个相同对象的场合较为适用
	+ 分区大小不等
2. 内存分配
	+ 按分区大小排队,建立一张分区使用表:起始地址,大小,状态

最早出现的,可用于多道程序系统中的存储管理方式	
####4.3.3动态分区分配
1. 动态分区分配中的数据结构
	+ 空闲分区表
	+ 空闲分区链
2. 动态分区分配算法:从空闲分区表/链中选出以分区分配给作业
	+ [基于顺序搜索的动态分区分配算法](#434)
	+ [基于索引搜索的动态分区分配算法](#435)
3. 分区分配操作
	+ 分配内存
		- $请求分区大小u.size,表/链中空闲分区大小m.size\\\
		若 m.size-u.size \leqslant size(事先规定的不再切割的剩余区的大小)\\\
		说明多余部分太小,可不再切割,将整个分区分配给请求者\\\
		否则(即多余部分超过size)便从该分区中按请求的大小划分出一块内存空间分配出去$
	+ 回收内存
	进程运行完毕释放内存时,<u>系统根据回收区的首地址从空闲区链/表中找到插入点</u>
	四种情况
		- 回收区上边紧挨着一个空闲区:合并,修改前一分区大小
		- 回收区下边紧挨着一个空闲区:合并,将回收区首址作为新空闲区的首址,大小为二者之和
		- 回收区上下紧挨着一个空闲区:合并,使用前一分区的表项和首址,取消后一分区的表项,大小为三者之和
		- 回收区上下都不是空闲区:为回收区新建一个表项
#####4.3.4基于顺序搜索的动态分区分配算法
顺序搜索:依次搜索空闲分区链上的空闲分区,去寻找一个其大小能满足要求的分区

1. 首次适应算法
	+ 空闲分区链<u>以地址递增的次序链接</u>
	+ 分配内存时,从链首开始顺序查找,找到一个大小满足要求的空闲分区为止
	+ 倾向于优先利用内存中低地址部分的空闲分区,从而保留了高地址部分的大空闲区
		- 也造成了低地址部分不断被划分,留下很多碎片的缺点
		- 每次查找又都是从低地址部分开始查找,增加了查找空闲分区的开销
2. 循环首次适应算法
	+ 从上次找到空闲分区的下一个空闲分区开始查找
		- 通过设置一个起始查寻指针,用于指示下一次其实查寻的空闲分区,**并采用循环查找方式**
	+ 使内存中的空闲分区分布得较为均匀,减少了查找空闲分区时的开销
	+ 会缺乏大的空闲分区
3. 最佳适应算法
	+ 空闲分区<u>按其容量从小到大顺序链接</u>
	+ 把既能满足要求,又是最小的空闲分区分配给作业
	+ 孤立地看,最佳适应算法时最佳的,在宏观上,**由于每次分配后所切割下来的剩余部分总是最小的**
	会留下许多难以利用的碎片
4. 最坏适应算法
	+ 与最佳适应算法策略相反,
		- 所有空闲分区按其容量以从大到小的顺序形成一个空闲分区链
		- 挑选一个最大的空闲区,从中分割一部分给作业使用
	+ 查找时,只要看第一个分区能否满足作业要求即可

基于顺序搜索的动态分区分配算法,适用于不太大的系统
当系统很大,分区表/链就会特别长,应采用基于索引搜索的动态分区分配算法	
#####4.3.5基于索引搜索的动态分区分配算法

1. 快速适应法/分类搜索法
	+ 将空闲分区按容量大小分类,对每一类具有相同容量的所有空闲分区,单独设立一个空闲分区链
		- 这样系统中有多个空闲分区链
		- 内存中设立一个管理索引表,每个表项对应一种空闲分区大小,记录链表指针
	+ 分配空闲分区
		1. 根据进程长度,从索引表中寻找能容纳它的最小空闲分区链
		2. 从链表中去下第一块分配
	+ 优点
		- 不分割分区从而不产生碎片
		- 查找效率高
	+ 缺点:
		- 为了有效合并分区,分区归还主存时,算法复杂,,,????
		- 以进程为单位分配分区,一个分区只属于一个进程,存在一定的浪费
2. 伙伴系统
	+ 分区按大小分类,**大小均为2^k**
	+ $当需要为进程分配一个长度为n的存储空间时,计算一个i值,使2^{i-1} < n \leqslant 2^i\\\
	在空闲分区大小为2^i的空闲分区链中查找$
		- 若找到,分配给进程即可
		- 若找不到,$依次从分区大小为2^{i+1},2^{i+2}...的分区中寻找,找到一个大小为2^j的分区\\\
		分割为一对伙伴,\\\
		一个加入到大小为2^{j-1}的分区中,另一个用于分配和进一步分割$
	+ 分配与回收的时空性能
		- ....
3. 哈希算法
	+ 空闲分区可以利用空闲分区表中的分布规律,建立哈希函数
	构造一张以空闲分区大小为关键字的哈希表
	+ 通过哈希计算,根据分区大小找到相应的空闲分区链表
####4.3.6动态可重定位分区分配
1. 紧凑
	+ 通过内存中作业的位置,把原来多个分数小分区拼接成一个大分区
	+ 紧凑之后,要对移动了的程序进行重定位
2. 动态重定位
	+ 在系统中增设一个重定位寄存器
3. 动态重定位的分区分配算法
	+ 与动态分区分配算法的区别仅在于<u>增加了紧凑的功能</u>
	当不能找到一个足够大的空闲分区来分配内存时,
	尝试"紧凑"一下,看所有小的空闲分区的容量总和是否满足要求
###4.4对换
####4.4.1多道程序环境下的对换技术
对换的引入

内存中的进程被阻塞,外存上有许多作业等待执行

对换:把内存中暂时不能运行的进程,暂时不用的程序或数据换出到外存上,腾出足够的内存空间
把已具备运行条件的进程或进程所需要的程序和数据换入内存

系统中设置一个对换进程,将内存中暂时不能运行的进程调出到磁盘对换区

对换的类型

+ 整体对换/进程对换,处理机中级调度,以整个进程为单位
+ 页面对换,以进程的一个页面/分段为单位
	- 是实现请求分页和请求分段式存储管理的基础

为了实现进程对换,系统必须实现三方面的功能

+ 4.4.2对换空间的管理
	1. 对换空间管理的主要目标
	<u>具有对换功能的OS把磁盘空间分为文件区和对换区</u>
		+ 文件区管理主要目标:提高存储空间利用率,采用离散分配
		+ 对换区管理主要目标:提高进程换入换出的速度,采用连续分配
	2. 对换区空闲盘块管理中的数据结构
		+ 空闲分区表,
		+ 空闲分区链
	3. 对换空间的分配与回收
	与内存的连续分配中的动态分区分配差不多
+ 4.4.3进程的换入与换出
	+ 进程的换出
		1. 选择被换出的进程
			+ 首先选择处于阻塞状态/睡眠状态的进程
			有多个时,选择优先级最低的
				- 为防止低优先级进程频繁被换出,还要考虑进程在内存中的驻留时间
			+ 没有阻塞进程,选择优先级最低的就绪进程
			+ **只能换出非共享的程序和数据段**
		2. 进程换出过程,
			+ 申请对换空间,申请成功启动磁盘,对换
			+ 修改进程PCB和内存分配表
	+ 进程的换入,<u>对换进程定时执行换入操作</u>
###4.5分页存储管理方式,离散分配方式
将一个进程直接分散地装入到许多不相邻接的分区中

根据离散分配时所分配地址空间的基本单位的不同,将离散分配方式分为以下三种

+ 分页存储管理
+ 分段存储管理
+ 段页式存储管理
####4.5.1分页存储管理的基本方法
将用户程序的地址空间分为若干个固定大小的页面
将内存空间分为若干个物理块

1. 页面和物理块
	+ 将进程的若干个页分别转入到不相邻接的物理块中
		- 由于进程的最后一页经常装不满,形成了不可利用的碎片,称为"页内碎片"
	+ 页面大小
		- 减小页面大小有利于提高内存利用率,但会使页表过长
		- 页面过大会使页内碎片增大
2. 地址结构

|页号|位移量|
|----|------|
|P|W|

3. 页表
	+ 进程的各个页离散的存储在内存的物理块中,进程若要正确运行,
	要能在内存中找到每个页面所对应的物理块,系统就需要为进程建立一张页表
	**在该进程地址空间内的所有页,依次在页表中有一页表项,记录相应页在内存中的物理块号**
		- 在虚拟内存中,是所有页都有一个页表项,表示了此页是否调入了内存
	+ 在页表中设置存取控制字段
####4.5.2地址变换机构
::将逻辑地址的页号转换为内存中的物理块号

1. 基本的地址变换机构
	+ 页表寄存器PTR(Page-Table Register),存放页表在内存中的始址和页表的长度
	进程为执行时,页表的始址和页表长度信息存放在本进程的PCB中,
	当进程获取处理机时将这两个数据装入寄存器
	+ 过程:(有硬件执行
		- 分页地址变换机构自动将有效地址分为页号和页内地址
		比较页号和页表长度,判断是否出现越界错误
		- 若无越界错误,将$页表始址+页号\times页表项长度$就得到了该页项在页表中的位置
2. 具有快表的地址变换机构
	+ 页表在内存中,CPU取数据要两次访存,
	一次访问页表得到物理地址,第二次用得到的地址取数据
	+ 为了提高地址变换速度,
	在地址变换机构中增设一个具有并行查寻能力的特殊高速寄存器,**快表**
	<u>用以存放当前访问的那些页表项</u>
	+ 过程:
		- 得到页号后先在快表中查找看其中有无匹配的页号
			+ 如果找到,可直接从快表中读出物理块号
			+ 找不到,就要访问内存中的页表
				- **同时要重新修改页表**
				甚至可能要替换页表
	+ 由于成本的关系,快表不可能太大,通常存放16~512个表项
####4.5.3访问内存的有效时间
+ 未引入快表:$访存时间设为t\\\
EAT=t+t$
+ 引入快表:$命中率设为a,查找快表用时间设为\lambda\\\
获取物理块号的时间=a\lambda+(1-a)(t+\lambda)\\\
从而EAT=a\lambda+(1-a)(t+\lambda)+t=2t+\lambda - t \times a$
####4.5.4两级页表和多级页表
当逻辑地址位数较高时,页表中页表项的数目会很多,从而页表会很大
如何在内存中存放较大的页表
两个方法来解决

1. 对于页表所需的内存空间,采用离散分配方式
2. 只将当前需要的部分也表项调入内存,其余页表项仍驻留在磁盘上,需要时再调入

两级页表
两级页表结构

|$P_1$|$P_2$|d|
|-|-|-|
|外层页页表的索引|页表分页的索引|页内地址|

将页表进行分页,<u>每个页面的大小与内存物理块的大小相同,并为他们编号</u>
然后离散地将各个页面分别存放在不同的物理块中
**为离散分配的页表再建立一张页表,称为外层页表**

外层页表的每个页表项中记录了页表分页的物理块号:$0\#页表存放在1011\#物理块中$
页表分页的每个页表项中记录了进程的某夜在内存中的物理块号:$0\#页存放在1\#物理块中$

为了实现地址变换,需要一个$#外层页表寄存器#$,存放外层页表的始址
<u>*页表该占用的内存空间/页表项的数目还是那么多,只是离散存放了*</u>
能够用较少的内存空间存放页表的唯一方法是,仅把当前需要的一批页表项调入内存

+ 在采用两级页表结构的情况下,对应正在运行的进程(虽然只调入需要的页表项)但是
**必须将其外层页表调入内存**
	- 为了表征某页的页表是否已经调入内存中,应在外层页表中增设一个状态位
		+ 请求调页

多级页表
地址空间再增大,就要用多级也变才能放得下---->页表分页的信息
####4.5.5反置页表		
1. 反置页表的引入
$页表::页号\rightarrow (页表项中:物理块号\\\
反置页表:物理块号\rightarrow (页表项中:页号+进程标识符$
2. 地址变换
$页表::根据序号找内容\\\
反置页表:根据内容找序号$

**为什么反置页表相比多级页表有效地较少了内存占用,,?**

+ <u>*反置页表项数目取决于物理地址空间大小*</u>
+ <u>*页表项数目取决于逻辑地址空间大小*</u>
+ 逻辑地址空间大小往往大于物理地址空间大小